
#include "stm32f10x.h"
#include "Stm32f10x_tim.h"
#include "stm32f10x_i2c.h"
#include "libUSARTComm.h"
#include "misc.h"
#include "stdbool.h"
#include "stdio.h"
#include "string.h"

#define BOARD_LED 				GPIO_Pin_5
#define BOARD_LED_PORT			GPIOB
#define USART3_TX				GPIO_Pin_8
#define USART3_RX				GPIO_Pin_9
#define SMBUS_PORT				I2C2
#define MAX_TIMEOUT				40000
#define STM32L4_ADDRESS			0x52
#define BMS_PACK_VOLTAGE_REG	0x01
#define TIMER_VALUE				500
#define AIRSPEED_ADDRESS		0x50

uint8_t TxData[16];
uint8_t Date_Info[17] = "0601072017,171105";
char Addrs = 0x0A;
void SMBus_Init();
void Board_LED_Init();
void Board_LED_Toggle();
void Timer_Init();
void USART_COM_Init();
void USART_Transmit_Data(void *TxBuffer,uint8_t Size);
uint8_t SMBus_Write_Data(uint8_t Device_Address,uint8_t *TxBuffer,uint8_t Size);
void Read_Airspeed_Data(uint8_t *RxBuffer,uint8_t Size);
uint8_t SMBus_Read_Data(uint8_t Device_Address,uint8_t *RxBuffer,uint8_t Size);

USART_InitTypeDef USART_InitStructure;
USART_TypeDef DATA;
uint8_t RecData = 0,RecData1;
uint64_t Count = 0;
bool _50HZ_Flag = false;
uint8_t Addr = 255;
uint8_t Length = 0;
uint8_t ReadData[24];
uint8_t Array[14] = {'A','B','C','D','E','F','G','H','I','J','K','L'};
uint8_t Address[13] = {0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x0A,0x0B};
bool Read_Request = false;
bool Start = false;

void TIM3_IRQHandler(void)
{
    if ( TIM_GetITStatus(TIM3,TIM_IT_Update) != RESET )
	{
		TIM_ClearITPendingBit(TIM3,TIM_FLAG_Update);
		_50HZ_Flag = true;
	}
}
int main(void)
{
	uint8_t i = 0;
	uint8_t Sent_data[15] = {'A','B','C','D','E','F','G','H','I','J','K','L','M','N',0x0D};
	uint8_t Slave_Address = 0x52;
	bool Data_Send = true;
	char Buffer[20];
	Board_LED_Init();
	USART_COM_Init();
	Timer_Init();
	SMBus_Init();
	USART_Transmit_Data("Booted",6);
	while (1)
	{
		if(_50HZ_Flag == true)
		{
			if(Start == true)
			{
				if(i > 11)
				{
					i = 0;
				}
				RecData = Array[i++];
				USART_Transmit_Data(&RecData,1);
				switch (RecData)
				{
						case 'A':
							Sent_data[0] = Address[0];
							Read_Request = true;
							break;
						case 'B':
							Sent_data[0] = Address[1];
							Read_Request = true;
							break;
						case 'C':
							Sent_data[0] = Address[2];
							Read_Request = true;
							break;
						case 'D':
							Sent_data[0] = Address[3];
							Read_Request = true;
							break;
						case 'E':
							Sent_data[0] = Address[4];
							Read_Request = true;
							break;
						case 'F':
							Sent_data[0] = Address[5];
							Read_Request = true;
							break;
						case 'G':
							Sent_data[0] = Address[6];
							Read_Request = true;
							break;
						case 'H':
							Sent_data[0] = Address[7];
							Read_Request = true;
							break;
						case 'I':
							Sent_data[0] = Address[8];
							Read_Request = false;
							Count = 17;
							break;
						case 'J':
							Sent_data[0] = Address[9];
							TxData[0] = 0x09;
							TxData[1] = 0x00;
							Read_Request = false;
							Count = 2;
							break;
						case 'K':
							Sent_data[0] = Address[9];
							TxData[0] = 0x08;
							TxData[1] = 0x00;
							Read_Request = false;
							Count = 2;
							break;
						case 'L':
							Sent_data[0] = Address[9];
							TxData[0] = 0x04;
							TxData[1] = 0x00;
							Read_Request = false;
							Count = 2;
							break;

						default:
							Data_Send = false;
							break;
					}

				if(Read_Request == true && Data_Send == true)
				{
					SMBus_Write_Data(Slave_Address,&Sent_data[0],1);
					SMBus_Read_Data((uint8_t) STM32L4_ADDRESS, ReadData, 4);
					uint8_t temp = Sent_data[0];
					uint8_t Length = sprintf(Buffer, "Cell[%d] = %fV\r",temp, *(float*) &ReadData);
					USART_Transmit_Data(Buffer, Length);
				}
				else if (Read_Request == false && Data_Send == true)
				{
					SMBus_Write_Data(Slave_Address,&Sent_data[0],1);
					SMBus_Read_Data((uint8_t)STM32L4_ADDRESS, &ReadData[0],1);
					if(ReadData[0] == 0xFF)
					{
						if(Count == 17)
						{
							SMBus_Write_Data(Slave_Address,Date_Info,17);
//							USART_Transmit_Data(Date_Info, 17);
						}
						else if (Count == 2)
						{
							SMBus_Write_Data(Slave_Address,TxData,2);
//							USART_Transmit_Data(TxData, 2);
						}
					}
				}
			}
			RecData = 0;
			Board_LED_Toggle();
			_50HZ_Flag = false;
		//	memset(ReadData,0,sizeof(ReadData));
		//	memset(Buffer,0,sizeof(Buffer));
		}
//		Count++;
//		if((Count%2) == 0)
//		{
//			Board_LED_Toggle();
//		}
//		if(Count > 400000000000)
//		{
//			Count = 0;
//		}
	}
}

void Board_LED_Init()
{
	GPIO_InitTypeDef GPIO_InitStructure;
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
	GPIO_InitStructure.GPIO_Pin = BOARD_LED;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(BOARD_LED_PORT, &GPIO_InitStructure);
}
void Board_LED_Toggle()
{
	GPIOB->ODR ^= BOARD_LED;
//	GPIOB->ODR ^= GPIO_Pin_10;
}

void SMBus_Init()
{
	I2C_InitTypeDef SMBus_InitStructure;
	GPIO_InitTypeDef GPIO_InitStructure;

	/* Enable I2C and GPIO clocks */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);

	/* Configure SMBus pins: SCL and SDA */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
	GPIO_Init(GPIOB, &GPIO_InitStructure);

	/* SMBus configuration */
	SMBus_InitStructure.I2C_Mode = I2C_Mode_I2C;//I2C_Mode_SMBusHost;
	SMBus_InitStructure.I2C_ClockSpeed = 100000;
	SMBus_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
	SMBus_InitStructure.I2C_OwnAddress1 = 0x01;
	SMBus_InitStructure.I2C_Ack = I2C_Ack_Enable;
	SMBus_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;

	I2C_Init(I2C2, &SMBus_InitStructure);

	I2C_Cmd(I2C2, ENABLE);
}

uint8_t SMBus_Write_Data(uint8_t Device_Address,uint8_t *TxBuffer,uint8_t Size)
{
	uint8_t Index = 0;
	int32_t Timeout = MAX_TIMEOUT;

	while (I2C_GetFlagStatus(SMBUS_PORT, I2C_FLAG_BUSY) && --Timeout > 1);

	if(Timeout < 1)
	{
		I2C_GenerateSTOP(SMBUS_PORT, ENABLE);
		SMBus_Init();
	}

	Timeout = MAX_TIMEOUT;
	I2C_GenerateSTART(SMBUS_PORT, ENABLE);

	while ((!I2C_CheckEvent(SMBUS_PORT, I2C_EVENT_MASTER_MODE_SELECT)) && --Timeout > 1);

	if(Timeout < 1)
	{
		USART_Transmit_Data("Restart1\r",9);
		I2C_GenerateSTOP(SMBUS_PORT, ENABLE);
		SMBus_Init();
		return 0;
	}

	I2C_Send7bitAddress(SMBUS_PORT, Device_Address, I2C_Direction_Transmitter);

	Timeout = MAX_TIMEOUT;
	while ((!I2C_CheckEvent(SMBUS_PORT, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)) && --Timeout > 1);

	if(Timeout < 1)
	{
		USART_Transmit_Data("Restart2\r",9);
		I2C_GenerateSTOP(SMBUS_PORT, ENABLE);
//		I2C_GenerateSTOP(SMBUS_PORT, ENABLE);
		SMBus_Init();
		return 0;
	}
	/* Send the data */
	for (Index = 0; Index < Size; Index++)
	{
		I2C_SendData(SMBUS_PORT, TxBuffer[Index]);
		Timeout = MAX_TIMEOUT;
		while ((!I2C_CheckEvent(SMBUS_PORT, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) && --Timeout > 0);
		if(Timeout < 1)
		{
			I2C_GenerateSTOP(SMBUS_PORT, ENABLE);
			USART_Transmit_Data("Restart3\r",9);
//			I2C_GenerateSTOP(SMBUS_PORT, ENABLE);
			SMBus_Init();
			return 0;
		}
	}

	I2C_GenerateSTOP(SMBUS_PORT, ENABLE);

	return 1;
}

uint8_t SMBus_Read_Data(uint8_t Device_Address,uint8_t *RxBuffer,uint8_t Size)
{
	uint8_t Index = 0;
	uint16_t Timeout = MAX_TIMEOUT;

	I2C_AcknowledgeConfig(SMBUS_PORT,ENABLE);

	while (I2C_GetFlagStatus(SMBUS_PORT, I2C_FLAG_BUSY) && --Timeout > 1 );

	if (Timeout < 1)
	{
		I2C_GenerateSTOP(SMBUS_PORT, ENABLE);
		SMBus_Init();
	}
//
	I2C_GenerateSTART(SMBUS_PORT, ENABLE);

	Timeout = MAX_TIMEOUT;
	while ((!I2C_CheckEvent(SMBUS_PORT, I2C_EVENT_MASTER_MODE_SELECT)) && --Timeout > 1);
	if(Timeout < 1)
	{
		I2C_GenerateSTOP(SMBUS_PORT, ENABLE);
		USART_Transmit_Data("Restart4\r",9);
	}

	I2C_AcknowledgeConfig(SMBUS_PORT, ENABLE);
	Timeout = MAX_TIMEOUT;
	I2C_Send7bitAddress(SMBUS_PORT, Device_Address, I2C_Direction_Receiver);
	while ((!I2C_CheckEvent(SMBUS_PORT, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED)) && --Timeout > 1);

	if(Timeout < 1)
	{
		USART_Transmit_Data("Restart5\r",9);
		I2C_GenerateSTOP(SMBUS_PORT, ENABLE);
		SMBus_Init();
		return 0;
	}

//	Timeout = MAX_TIMEOUT;
//	while ((!I2C_CheckEvent(SMBUS_PORT, I2C_EVENT_MASTER_BYTE_RECEIVED)) && --Timeout > 1);

//	if(Timeout < 1)
//	{
//		USART_Transmit_Data("Restart6\r",9);
//	}

	for(Index = 0; Index < Size ;Index++)
	{
		if(Index == Size - 1)
		{
			I2C_AcknowledgeConfig(SMBUS_PORT,DISABLE);
		    I2C_GenerateSTOP(SMBUS_PORT, ENABLE);
		}
		Timeout = MAX_TIMEOUT;
		while ((!I2C_CheckEvent(SMBUS_PORT, I2C_EVENT_MASTER_BYTE_RECEIVED)) && --Timeout > 1);
		if(Timeout < 1)
		{
			USART_Transmit_Data("Restart7\r",9);
			I2C_GenerateSTOP(SMBUS_PORT, ENABLE);
			SMBus_Init();
			return 0;
		}

		RxBuffer[Index] = I2C_ReceiveData(SMBUS_PORT);
		Timeout = MAX_TIMEOUT;

	}

	I2C_AcknowledgeConfig(SMBUS_PORT,ENABLE);

//    PEC_Byte = I2C_ReceiveData(SMBUS_PORT);

//    expected_pec = SMBus_CRC8(((uint32_t)ReadAddr << 16) | ((uint32_t)buff[0] << 8) | buff[1]);

    return 1;

}

void USART_Transmit_Data(void *TxBuffer,uint8_t Size)
{
	while(Size > 0)
	{
		while (USART_GetFlagStatus(USART3, USART_FLAG_TXE) == RESET);
		USART3->DR = (*(uint8_t*)TxBuffer & 0xff);
		TxBuffer++;
		Size--;
	}
}

void USART_COM_Init()
{
	GPIO_InitTypeDef GPIO_InitStruct;
	NVIC_InitTypeDef NVIC_InitStructure;

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO | RCC_APB2Periph_GPIOD, ENABLE);
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
	GPIO_PinRemapConfig(GPIO_FullRemap_USART3, ENABLE);

	GPIO_InitStruct.GPIO_Pin = USART3_TX;
	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_Init(GPIOD, &GPIO_InitStruct);

	GPIO_InitStruct.GPIO_Pin = USART3_RX;
	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;
	GPIO_Init(GPIOD, &GPIO_InitStruct);

	NVIC_PriorityGroupConfig(NVIC_IPR0_PRI_2);
	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

	USART_InitStructure.USART_BaudRate = 115200;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
	USART_Init(USART3, &USART_InitStructure);
	USART_Cmd(USART3, ENABLE);
	USART_ITConfig(USART3,USART_IT_RXNE,ENABLE);
}

void USART3_IRQHandler(void)
{
	if ((USART3->SR & USART_FLAG_RXNE) != (u16) RESET)
	{
		RecData = (u8) USART_ReceiveData(USART3);
		Start = true;
		if(RecData == 'M')
		{
			NVIC_SystemReset();
			RecData = 0;
		}
//		else if (RecData1 == 'S')
//		{
//			Start = true;
//		}
//		else if (RecData1 == 'C')
//		{
//			SMBus_Init();
//		}
	}
}

void Timer_Init()
{
	NVIC_InitTypeDef NVIC_InitStructure;
	TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);

	NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

	TIM_TimeBaseStructure.TIM_Period = TIMER_VALUE;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseStructure.TIM_Prescaler = 7199;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;

	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
	TIM_ClearFlag(TIM3, TIM_FLAG_Update);
	TIM_ITConfig(TIM3, TIM_IT_Update, ENABLE);
	TIM_Cmd(TIM3, ENABLE);
}

void Read_Airspeed_Data(uint8_t *RxBuffer,uint8_t Size)
{
	uint8_t Index = 0;
//	while (I2C_GetFlagStatus(SMBUS_PORT, I2C_FLAG_BUSY));

	I2C_GenerateSTART(SMBUS_PORT, ENABLE);

	while (!I2C_CheckEvent(SMBUS_PORT, I2C_EVENT_MASTER_MODE_SELECT));

	I2C_Send7bitAddress(SMBUS_PORT, (uint8_t)AIRSPEED_ADDRESS, I2C_Direction_Receiver);

	while (!I2C_CheckEvent(SMBUS_PORT, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));

	I2C_AcknowledgeConfig(SMBUS_PORT, ENABLE);

	for (Index = 0; Index < Size; Index++)
	{
		if (Index == (Size - 1))
		{
			I2C_AcknowledgeConfig(SMBUS_PORT, DISABLE);
			I2C_GenerateSTOP(SMBUS_PORT, ENABLE);

		}
		RxBuffer[Index] = I2C_ReceiveData(SMBUS_PORT);
		while (!I2C_CheckEvent(SMBUS_PORT, I2C_EVENT_MASTER_BYTE_RECEIVED));
	}

	I2C_AcknowledgeConfig(SMBUS_PORT, ENABLE);
}
