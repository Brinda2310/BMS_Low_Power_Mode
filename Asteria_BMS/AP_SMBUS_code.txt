
#include "stm32f10x.h"
#include "Stm32f10x_tim.h"
#include "stm32f10x_i2c.h"
#include "libUSARTComm.h"
#include "misc.h"
#include "stdbool.h"
#include "stdio.h"
#include "string.h"

#define BOARD_LED 				GPIO_Pin_5
#define BOARD_LED_PORT			GPIOB
#define USART3_TX				GPIO_Pin_8
#define USART3_RX				GPIO_Pin_9
#define SMBUS_PORT				I2C2
#define MAX_TIMEOUT				10000
#define STM32L4_ADDRESS			0x52
#define BMS_PACK_VOLTAGE_REG	0x01
#define TIMER_VALUE				200
#define AIRSPEED_ADDRESS		0x50

uint8_t TxData[16];
uint8_t Date_Info[17] = "0514072017,224505";
char Addrs = 0x0A;
bool I2C_problem = false;

void SMBus_Init();
void Board_LED_Init();
void Board_LED_Toggle();
void Timer_Init();
void USART_COM_Init();
void USART_Transmit_Data(void *TxBuffer,uint8_t Size);
uint8_t SMBus_Write_Data(uint8_t Device_Address,uint8_t *TxBuffer,uint8_t Size);
void Read_Airspeed_Data(uint8_t *RxBuffer,uint8_t Size);
uint8_t SMBus_Read_Data(uint8_t Device_Address,uint8_t *RxBuffer,uint8_t Size);

USART_InitTypeDef USART_InitStructure;
USART_TypeDef DATA;
uint8_t RecData = 0,RecData1;
uint64_t Count = 0;
bool _50HZ_Flag = false,_10Hz_Flag = false;
uint8_t Addr = 255;
uint8_t Length = 0;
uint8_t Array[14] = {'A','B','C','D','E','F','G','H','I','J','K','L'};
uint8_t Address[13] = {0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x0A,0x0B};
bool Read_Request = false;
bool Start = false;
bool Send_Date = false;
uint32_t Current_Value = 0, Prev_Value = 0;
static bool once = false;

volatile uint32_t time_from_boot_msb = 0;
uint32_t time_from_boot_buff = 0;
uint32_t millis_now = 0,millis_old = 0;
bool Stop_Time_Send = false;
int Counter = 0;

uint8_t Sent_data[15] = {'A','B','C','D','E','F','G','H','I','J','K','L','M','N',0x0D};
uint8_t Slave_Address = 0x52;
char Buffer[200];

typedef union
{
	uint8_t ReadData[32];
	float Values[8];
}Pack_Info;

Pack_Info Pack_Data;

void TIM3_IRQHandler(void)
{
    if ( TIM_GetITStatus(TIM3,TIM_IT_Update) != RESET )
	{
		TIM_ClearITPendingBit(TIM3,TIM_FLAG_Update);
		_50HZ_Flag = true;
//		time_from_boot_msb++;
	}
}

uint32_t get_time_from_boot()
{
	int time_count = (TIM_GetCounter(TIM3)/10);
	time_from_boot_buff = (uint32_t)((time_from_boot_msb*6000) + time_count);
	return time_from_boot_buff;
}

void Check_Timer()
{
	millis_now = get_time_from_boot();

	if ((millis_now - millis_old) >= 20) //time granularity at 10ms
	{
		millis_old = millis_now; //store reference time
		_50HZ_Flag = true;
	}
}

void USART3_IRQHandler(void)
{
	if ((USART3->SR & USART_FLAG_RXNE) != (u16) RESET)
	{
		RecData = (u8) USART_ReceiveData(USART3);

		if(RecData == 'M')
		{
			NVIC_SystemReset();
			RecData = 0;
		}

		if(RecData == 'S')
		{
			Start = true;
			USART_Transmit_Data("ff\r",3);
			Stop_Time_Send = false;
		}
		else if (RecData == 'V')
		{
			Send_Date = true;
		}
		else if(RecData == 'W')
		{
			SMBus_Init();
		}
//		else if (RecData1 == 'S')
//		{
//			Start = true;
//		}
//		else if (RecData1 == 'C')
//		{
//			SMBus_Init();
//		}
	}
}

int main(void)
{
	uint8_t i = 0;
	Board_LED_Init();
	USART_COM_Init();
	Timer_Init();
	SMBus_Init();
	USART_Transmit_Data("Booted",6);
	Sent_data[0] = 0x0C;

	while (1)
	{
//		Check_Timer();

		if(_50HZ_Flag == true)
		{
			_50HZ_Flag = false;
			Counter++;
			Board_LED_Toggle();
			if(Counter >= 5)
			{
				Counter = 0;
				_10Hz_Flag = true;
			}

		}
		if(_10Hz_Flag == true && Start == true)
		{
//			Start = false;
			if (I2C_problem == true)
			{
				Count++;
				if(once == false)
				{
					once = true;
					SMBus_Init();
				}
				if (Count >= 10)
				{
					Count = 0;
					i = 0;
					once = false;
					I2C_problem = false;
					USART_Transmit_Data("Restart\r",8);
				}
			}
			else
				Count = 0;

			memset(Buffer,0,sizeof(Buffer));
			Length = 0;
			Length = sprintf(Buffer, "C1 = %0.2fV\r", Pack_Data.Values[0]);
			Length += sprintf(&Buffer[Length], "C2 = %0.2fV\r", Pack_Data.Values[1]);
			Length += sprintf(&Buffer[Length], "C3 = %0.2fV\r", Pack_Data.Values[2]);
			Length += sprintf(&Buffer[Length], "C4 = %0.2fV\r", Pack_Data.Values[3]);
			Length += sprintf(&Buffer[Length], "C5 = %0.2fV\r", Pack_Data.Values[4]);
			Length += sprintf(&Buffer[Length], "C6 = %0.2fV\r", Pack_Data.Values[5]);
			Length += sprintf(&Buffer[Length], "C7 = %0.2fV\r", Pack_Data.Values[6]);
			Length += sprintf(&Buffer[Length], "C8 = %0.2fV\r", Pack_Data.Values[7]);

			USART_Transmit_Data(Buffer, Length);
			Send_Date = false;
			memset(&Pack_Data.ReadData[0],0,sizeof(Pack_Data));

			if(SMBus_Write_Data(Slave_Address,&Sent_data[0],1) == 1)
			{
				if(SMBus_Read_Data((uint8_t) (STM32L4_ADDRESS | 0x01), &Pack_Data.ReadData[0], 32) == 0)
				{
					i = 0;
					RecData = 0;
					_10Hz_Flag = false;
					break;
				}
			}

			i = 0;
			RecData = 0;
			_10Hz_Flag = false;
		}
	}
}

void Board_LED_Init()
{
	GPIO_InitTypeDef GPIO_InitStructure;
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
	GPIO_InitStructure.GPIO_Pin = BOARD_LED;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(BOARD_LED_PORT, &GPIO_InitStructure);
}
void Board_LED_Toggle()
{
	GPIOB->ODR ^= BOARD_LED;
}

void SMBus_Init()
{
	I2C_InitTypeDef SMBus_InitStructure;
	GPIO_InitTypeDef GPIO_InitStructure;

	I2C_Cmd(SMBUS_PORT,DISABLE);
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, DISABLE);
	/* Enable I2C and GPIO clocks */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);

	/* Configure SMBus pins: SCL and SDA */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
	GPIO_Init(GPIOB, &GPIO_InitStructure);

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, ENABLE);

	/* SMBus configuration */
	SMBus_InitStructure.I2C_Mode = I2C_Mode_SMBusHost;//I2C_Mode_SMBusHost;
	SMBus_InitStructure.I2C_ClockSpeed = 100000;
	SMBus_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
	SMBus_InitStructure.I2C_OwnAddress1 = 0x01;
	SMBus_InitStructure.I2C_Ack = I2C_Ack_Enable;
	SMBus_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;

	I2C_Init(I2C2, &SMBus_InitStructure);

	I2C_Cmd(I2C2, ENABLE);
}

uint8_t SMBus_Write_Data(uint8_t Device_Address,uint8_t *TxBuffer,uint8_t Size)
{
	uint8_t Index = 0;
	int32_t Timeout = MAX_TIMEOUT;

	Timeout = MAX_TIMEOUT;
	I2C_GenerateSTART(SMBUS_PORT, ENABLE);

	while ((!I2C_CheckEvent(SMBUS_PORT, I2C_EVENT_MASTER_MODE_SELECT)) && --Timeout > 1);

	if(Timeout < 1)
	{
		I2C_GenerateSTOP(SMBUS_PORT, ENABLE);
		I2C_problem = true;
		SMBus_Init();
		return 0;
	}

	I2C_Send7bitAddress(SMBUS_PORT, Device_Address, I2C_Direction_Transmitter);

	Timeout = MAX_TIMEOUT;
	while ((!I2C_CheckEvent(SMBUS_PORT, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)) && --Timeout > 1);

	if(Timeout < 1)
	{
		I2C_GenerateSTOP(SMBUS_PORT, ENABLE);
		I2C_problem = true;
		SMBus_Init();
		return 0;
	}
	/* Send the data */
	for (Index = 0; Index < Size; Index++)
	{
		I2C_SendData(SMBUS_PORT, TxBuffer[Index]);
		Timeout = MAX_TIMEOUT;
		while ((!I2C_CheckEvent(SMBUS_PORT, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) && --Timeout > 0);
		if(Timeout < 1)
		{
			I2C_GenerateSTOP(SMBUS_PORT, ENABLE);
			SMBus_Init();
			I2C_problem = true;
			return 0;
		}
	}

	I2C_GenerateSTOP(SMBUS_PORT, ENABLE);

	I2C_problem = false;
	return 1;
}

uint8_t SMBus_Read_Data(uint8_t Device_Address,uint8_t *RxBuffer,uint8_t Size)
{
	uint8_t Index = 0;
	uint16_t Timeout = MAX_TIMEOUT;

	while (I2C_GetFlagStatus(SMBUS_PORT, I2C_FLAG_BUSY) && --Timeout > 1 );

	if (Timeout < 1)
	{
		I2C_GenerateSTOP(SMBUS_PORT, ENABLE);
		SMBus_Init();
	}

	I2C_GenerateSTART(SMBUS_PORT, ENABLE);

	Timeout = MAX_TIMEOUT;
	while ((!I2C_CheckEvent(SMBUS_PORT, I2C_EVENT_MASTER_MODE_SELECT)) && --Timeout > 1);
	if(Timeout < 1)
	{
		I2C_GenerateSTOP(SMBUS_PORT, ENABLE);
		SMBus_Init();
		I2C_problem = true;
		return 0;
	}

	Timeout = MAX_TIMEOUT;
	I2C_Send7bitAddress(SMBUS_PORT, Device_Address, I2C_Direction_Receiver);
	while ((!I2C_CheckEvent(SMBUS_PORT, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED)) && --Timeout > 1);

	if(Timeout < 1)
	{
		I2C_GenerateSTOP(SMBUS_PORT, ENABLE);
		SMBus_Init();
		I2C_problem = true;
		return 0;
	}

	for(Index = 0; Index < Size ;Index++)
	{
		Timeout = MAX_TIMEOUT;
		while ((!I2C_CheckEvent(SMBUS_PORT, I2C_EVENT_MASTER_BYTE_RECEIVED)) && --Timeout > 1);
		if(Timeout < 1)
		{
			I2C_GenerateSTOP(SMBUS_PORT, ENABLE);
			SMBus_Init();
			I2C_problem = true;
			return 0;
		}

		I2C_AcknowledgeConfig(SMBUS_PORT,ENABLE);
		RxBuffer[Index] = I2C_ReceiveData(SMBUS_PORT);
	}

    I2C_GenerateSTOP(SMBUS_PORT, ENABLE);

	I2C_problem = false;

    return 1;

}

void USART_Transmit_Data(void *TxBuffer,uint8_t Size)
{
	while(Size > 0)
	{
		while (USART_GetFlagStatus(USART3, USART_FLAG_TXE) == RESET);
		USART3->DR = (*(uint8_t*)TxBuffer & 0xff);
		TxBuffer++;
		Size--;
	}
}

void USART_COM_Init()
{
	GPIO_InitTypeDef GPIO_InitStruct;
	NVIC_InitTypeDef NVIC_InitStructure;

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO | RCC_APB2Periph_GPIOD, ENABLE);
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
	GPIO_PinRemapConfig(GPIO_FullRemap_USART3, ENABLE);

	GPIO_InitStruct.GPIO_Pin = USART3_TX;
	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_Init(GPIOD, &GPIO_InitStruct);

	GPIO_InitStruct.GPIO_Pin = USART3_RX;
	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;
	GPIO_Init(GPIOD, &GPIO_InitStruct);

	NVIC_PriorityGroupConfig(NVIC_IPR0_PRI_2);
	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

	USART_InitStructure.USART_BaudRate = 115200;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
	USART_Init(USART3, &USART_InitStructure);
	USART_Cmd(USART3, ENABLE);
	USART_ITConfig(USART3,USART_IT_RXNE,ENABLE);
}

void Timer_Init()
{
	NVIC_InitTypeDef NVIC_InitStructure;
	TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);

	NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

	TIM_TimeBaseStructure.TIM_Period = TIMER_VALUE;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseStructure.TIM_Prescaler = 7199;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;

	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
	TIM_ClearFlag(TIM3, TIM_FLAG_Update);
	TIM_ITConfig(TIM3, TIM_IT_Update, ENABLE);
	TIM_Cmd(TIM3, ENABLE);
}

void Read_Airspeed_Data(uint8_t *RxBuffer,uint8_t Size)
{
	uint8_t Index = 0;
//	while (I2C_GetFlagStatus(SMBUS_PORT, I2C_FLAG_BUSY));

	I2C_GenerateSTART(SMBUS_PORT, ENABLE);

	while (!I2C_CheckEvent(SMBUS_PORT, I2C_EVENT_MASTER_MODE_SELECT));

	I2C_Send7bitAddress(SMBUS_PORT, (uint8_t)AIRSPEED_ADDRESS, I2C_Direction_Receiver);

	while (!I2C_CheckEvent(SMBUS_PORT, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));

	I2C_AcknowledgeConfig(SMBUS_PORT, ENABLE);

	for (Index = 0; Index < Size; Index++)
	{
		if (Index == (Size - 1))
		{
			I2C_AcknowledgeConfig(SMBUS_PORT, DISABLE);
			I2C_GenerateSTOP(SMBUS_PORT, ENABLE);

		}
		RxBuffer[Index] = I2C_ReceiveData(SMBUS_PORT);
		while (!I2C_CheckEvent(SMBUS_PORT, I2C_EVENT_MASTER_BYTE_RECEIVED));
	}

	I2C_AcknowledgeConfig(SMBUS_PORT, ENABLE);
}
