
#include "stm32f10x.h"
#include "Stm32f10x_tim.h"
#include "stm32f10x_i2c.h"
#include "libUSARTComm.h"
#include "misc.h"
#include "stdbool.h"
#include "stdio.h"
#include "string.h"
#include "ff.h"
#include "diskio.h"
#include "sdio_sd.h"
#include "log.h"
#include "math.h"


#define BOARD_LED 				GPIO_Pin_5
#define BOARD_LED_PORT			GPIOB
#define USART3_TX				GPIO_Pin_8
#define USART3_RX				GPIO_Pin_9
#define SMBUS_PORT				I2C2
#define MAX_TIMEOUT				100 //Initial Value = 10000
#define STM32L4_ADDRESS			0x52
#define BMS_PACK_VOLTAGE_REG	0x01
#define TIMER_VALUE				60000 // 1 = 100us
#define AIRSPEED_ADDRESS		0x50
#define I2Cx     				I2C2
#define ADDR_LIDAR				(uint8_t)(0x66 << 1)
#define ADDR_ASI				(uint8_t)(0x50)
#define ADDR_BMS				(uint8_t)(0x52)
#define ADDR_MAG				(uint8_t)(0x1E << 1)
#define Query_BMS_FULL				(uint8_t)(0x0C)
#define Query_BMS_C1				(uint8_t)(0x00)
#define Query_BMS_C2				(uint8_t)(0x01)
#define Query_BMS_C3				(uint8_t)(0x02)
#define Query_BMS_C4				(uint8_t)(0x03)
#define Query_BMS_C5				(uint8_t)(0x04)
#define Query_BMS_C6				(uint8_t)(0x05)
#define Query_BMS_PV				(uint8_t)(0x06)
#define Query_BMS_PA				(uint8_t)(0x07)

#define MAX_DATA_SIZE			2

#define WAIT_FOR_SENSOR_READY					600
#define BMS_TX_BUFFER_SIZE						10
#define BMS_RX_BUFFER_SIZE						40
#define BMS_DEVICE_ADDRESS						0x52
#define WRITE_DATA								0x00
#define READ_DATA								0x01
#define PACK_DATA_SIZE							32
#define SINGLE_QUERY_DATA_SIZE					4

void SMBus_Init();
void Board_LED_Init();
void Board_LED_Toggle();
void Timer_Init();
void USART_COM_Init();
void USART_Transmit_Data(void *TxBuffer,uint8_t Size);
uint8_t SMBus_Write_Data(uint8_t Device_Address,uint8_t *TxBuffer,uint8_t Size);
void Read_Airspeed_Data(uint8_t *RxBuffer,uint8_t Size);
uint8_t SMBus_Read_Data(uint8_t Device_Address,uint8_t *RxBuffer,uint8_t Size);
void Check_Timer();
uint32_t get_time_from_boot();
void TIM3_IRQHandler(void);

FATFS fs;         			/* Work area (file system object) for logical drive */
FIL Log_File;         		/* file objects */
FIL Summary_File;         	/* file objects */
FRESULT res = FR_OK;	  	/* Used to store the result obtained from FATFS library calls */
UINT bw;

USART_InitTypeDef USART_InitStructure;
USART_TypeDef DATA;

uint8_t RecData = 0;
bool _50HZ_Flag = false,_10Hz_Flag = false;
uint8_t Length = 0;
bool Send_GPS_Data = false,Query_Pack_Data = false;

volatile uint32_t time_from_boot_msb = 0;
uint32_t time_from_boot_buff = 0;
uint32_t millis_now = 0,millis_old = 0;
int Counter = 0;

bool BMS_Device_Enable = true;

typedef struct
{
	uint8_t Address;
	uint8_t Tx_Buffer[BMS_TX_BUFFER_SIZE];
	union
	{
		uint8_t Rx_Buffer[BMS_RX_BUFFER_SIZE];
		float Pack_Data[BMS_RX_BUFFER_SIZE/sizeof(float)];
	}Info;
	uint8_t Num_Tx_Bytes;
	uint8_t Tx_Buff_Index;
	uint8_t Rx_Buff_Index;
	uint8_t Max_Rx_Size;
	bool One_Cycle_Complete;
	bool I2C_Operation;
	bool Read_Request;
	bool Write_Request;
}BMS_Struct;

BMS_Struct BMS_Device;

char Buffer[200];

bool Start_Log = false;

enum results
{
	WRITE_REQUEST = 0,READ_REQUEST, NO_OPERATION
};

enum result_operation
{
	NOT_FINISHED = 0,FINISHED
};

bool I2C_Operation,Request_Complete = false,Operation_Complete = false;
uint8_t Index = 0;
uint8_t Sent_Data = 0x0C;

float *data_values[8];
char send_data[200];
int Num_Bytes = 0;
uint32_t status;
uint8_t data_bb[50];

void BMS_Init();

int main(void)
{
 	Board_LED_Init();
	USART_COM_Init();
	Timer_Init();

	SMBus_Init();

	USART_Transmit_Data("Booted\r",7);

	BMS_Init();

	while (1)
	{
		Check_Timer();

		if(_50HZ_Flag == true)
		{
			if(RecData == 'A')
			{
				BMS_Device.Write_Request = false;
				BMS_Device.Tx_Buff_Index = 0;

				if (BMS_Device.Tx_Buffer[BMS_Device.Tx_Buff_Index] == 0x07)
				{
					BMS_Device.Tx_Buffer[BMS_Device.Tx_Buff_Index++] = 0x0C;
				}
				else if (BMS_Device.Tx_Buffer[BMS_Device.Tx_Buff_Index]	== 0x0C)
				{
					BMS_Device.Tx_Buffer[BMS_Device.Tx_Buff_Index++] = 0x07;
				}

//				I2C_ITConfig(I2C2, I2C_IT_BUF | I2C_IT_EVT, ENABLE);
				BMS_Device.I2C_Operation = WRITE_REQUEST;
				I2C_GenerateSTART(I2C2, ENABLE);
				RecData = 0;
			}
			if(BMS_Device.Write_Request == true)
			{
				if(BMS_Device.One_Cycle_Complete == false)
				{
					BMS_Device.I2C_Operation = READ_REQUEST;
					if(BMS_Device.Tx_Buffer[BMS_Device.Tx_Buff_Index] == 0x0C)
					{
						BMS_Device.Rx_Buff_Index = PACK_DATA_SIZE;
						BMS_Device.Max_Rx_Size = PACK_DATA_SIZE;
					}
					else if(BMS_Device.Tx_Buffer[BMS_Device.Tx_Buff_Index] == 0x07)
					{
						BMS_Device.Rx_Buff_Index = SINGLE_QUERY_DATA_SIZE;
						BMS_Device.Max_Rx_Size = SINGLE_QUERY_DATA_SIZE;
					}

					for(int i = 0 ; i < 600; i++);
					I2C_GenerateSTART(I2C2, ENABLE);
				}
			}
			Board_LED_Toggle();
			_50HZ_Flag = false;
		}

		if(BMS_Device.One_Cycle_Complete == true)
		{
			uint8_t Len = 0;
			for( int i = 0; i < (BMS_Device.Max_Rx_Size/ sizeof(float)); i++)
			{
				Len += sprintf(&Buffer[Len],"%0.2f\r",BMS_Device.Info.Pack_Data[i]);
			}

//			Len += sprintf(&Buffer[Len],"%0.2f\r%0.2f\r%0.2f\r%0.2f\r%0.2f\r%0.2f\r%0.2f\r%0.2f\r\r",BMS_Device.Info.Pack_Data[0],BMS_Device.Info.Pack_Data[1],
//					BMS_Device.Info.Pack_Data[2],BMS_Device.Info.Pack_Data[3],BMS_Device.Info.Pack_Data[4],BMS_Device.Info.Pack_Data[5],
//					BMS_Device.Info.Pack_Data[6],BMS_Device.Info.Pack_Data[7]);
			USART_Transmit_Data(Buffer,Len);
			USART_Transmit_Data("\r",1);
			BMS_Device.One_Cycle_Complete = false;
		}
	}
}

void BMS_Init()
{
	uint32_t start_time = 0;
	BMS_Device_Enable = true;

	BMS_Device.Address = BMS_DEVICE_ADDRESS;
	BMS_Device.Write_Request = false;
	BMS_Device.Tx_Buffer[BMS_Device.Tx_Buff_Index++] = 0x0C;

	I2C_ITConfig(I2C2, I2C_IT_BUF | I2C_IT_EVT, ENABLE);
	start_time = get_time_from_boot();

	BMS_Device.I2C_Operation = WRITE_REQUEST;
	I2C_GenerateSTART(I2C2, ENABLE);

	while(BMS_Device.Write_Request == false && (get_time_from_boot() - start_time) < 10);

	BMS_Device.I2C_Operation = READ_REQUEST;
	BMS_Device.Rx_Buff_Index = PACK_DATA_SIZE;
	BMS_Device.Max_Rx_Size = PACK_DATA_SIZE;
	I2C_GenerateSTART(I2C2, ENABLE);
}

void I2C2_EV_IRQHandler(void)
{
	uint8_t temp = 0;
	status  = I2C_GetLastEvent(I2C2);

	switch (status)
	{
		case I2C_EVENT_MASTER_MODE_SELECT :
			if(BMS_Device.I2C_Operation == WRITE_REQUEST)
			{
				I2C_Send7bitAddress(I2C2, BMS_DEVICE_ADDRESS, I2C_Direction_Transmitter);
			}
			else if (BMS_Device.I2C_Operation == READ_REQUEST)
			{
				I2C_Send7bitAddress(I2C2, BMS_DEVICE_ADDRESS| 0x01, I2C_Direction_Receiver);
				I2C_AcknowledgeConfig(I2C2, ENABLE);
				I2C_ITConfig(I2C2, I2C_IT_BUF, ENABLE);
			}
			break;

		case I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED:  /* BUSY, MSL, ADDR, TXE and TRA flags */
			for(temp = 0; temp < BMS_Device.Tx_Buff_Index;temp++)
			{
				I2C_SendData(I2C2,BMS_Device.Tx_Buffer[temp]);
			}
			BMS_Device.Tx_Buff_Index = 0;
			break;
		case I2C_EVENT_MASTER_BYTE_TRANSMITTING:
		case I2C_EVENT_MASTER_BYTE_TRANSMITTED:
			I2C_GenerateSTOP(I2C2, ENABLE);
			USART_Transmit_Data("D\r",2);
			BMS_Device.Write_Request = true;
			break;

		case I2C_EVENT_MASTER_BYTE_RECEIVED:			/* BUSY, MSL and RXNE flags */
		case I2C_EVENT_BTF_RXNE_COMPLETED:

		  if(BMS_Device.Rx_Buff_Index == 1)
		  {
			BMS_Device.Info.Rx_Buffer[BMS_Device.Max_Rx_Size - (BMS_Device.Rx_Buff_Index--)] = I2C_ReceiveData(I2C2);
			I2C_AcknowledgeConfig(I2C2, DISABLE);
			I2C_GenerateSTOP(I2C2, ENABLE);
			BMS_Device.One_Cycle_Complete = true;
		  }
		  else
		  {
			BMS_Device.Info.Rx_Buffer[BMS_Device.Max_Rx_Size - (BMS_Device.Rx_Buff_Index--)] = I2C_ReceiveData(I2C2);
			I2C_AcknowledgeConfig(I2C2, ENABLE);
		  }
		break;

		default:
			break;
	}
}

void TIM3_IRQHandler(void)
{
    if ( TIM_GetITStatus(TIM3,TIM_IT_Update) != RESET )
	{
		TIM_ClearITPendingBit(TIM3,TIM_FLAG_Update);
		time_from_boot_msb++;
	}
}

uint32_t get_time_from_boot()
{
	int time_count = (TIM_GetCounter(TIM3)/10);
	time_from_boot_buff = (uint32_t)((time_from_boot_msb*6000) + time_count);
	return time_from_boot_buff;
}

void Check_Timer()
{
	millis_now = get_time_from_boot();

	if ((millis_now - millis_old) >= 20)
	{
		millis_old = millis_now; //store reference time
		_50HZ_Flag = true;
	}
}

void USART3_IRQHandler(void)
{
	if ((USART3->SR & USART_FLAG_RXNE) != (u16) RESET)
	{
		RecData = (u8) USART_ReceiveData(USART3);

		if(RecData == 'M')
		{
			NVIC_SystemReset();
			RecData = 0;
		}
		else if(RecData == 'G')
		{
			Query_Pack_Data = false;
			Send_GPS_Data = true;
		}
		else if (RecData == 'P')
		{
			Query_Pack_Data = true;
		}
		else if(RecData == 'W')
		{
			SMBus_Init();
		}
	}
}


void SMBus_Init()
{
	I2C_InitTypeDef I2C_InitStructure;
	GPIO_InitTypeDef GPIO_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;

	I2C_Cmd(SMBUS_PORT,DISABLE);
	I2C_ITConfig(I2C2, I2C_IT_BUF | I2C_IT_EVT, DISABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, DISABLE);
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, DISABLE);

	/* Enable I2C and GPIO clocks */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, ENABLE);

	/* Configure SMBus pins: SCL and SDA */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
	GPIO_Init(GPIOB, &GPIO_InitStructure);

	/* I2C configuration */
	I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
	I2C_InitStructure.I2C_ClockSpeed = 100000;
	I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
	I2C_InitStructure.I2C_OwnAddress1 = 0x01; // initially : 0x01
	I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
	I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;

	I2C_Cmd(SMBUS_PORT, ENABLE);

	I2C_Init(I2C2, &I2C_InitStructure);

	NVIC_InitStructure.NVIC_IRQChannel = I2C2_EV_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

	I2C_Cmd(I2C2, ENABLE);
}

void Board_LED_Init()
{
	GPIO_InitTypeDef GPIO_InitStructure;
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
	GPIO_InitStructure.GPIO_Pin = BOARD_LED;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(BOARD_LED_PORT, &GPIO_InitStructure);
}
void Board_LED_Toggle()
{
	GPIOB->ODR ^= BOARD_LED;
}

void USART_Transmit_Data(void *TxBuffer,uint8_t Size)
{
	while(Size > 0)
	{
		while (USART_GetFlagStatus(USART3, USART_FLAG_TXE) == RESET);
		USART3->DR = (*(uint8_t*)TxBuffer & 0xff);
		TxBuffer++;
		Size--;
	}
}

void USART_COM_Init()
{
	GPIO_InitTypeDef GPIO_InitStruct;
	NVIC_InitTypeDef NVIC_InitStructure;

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO | RCC_APB2Periph_GPIOD, ENABLE);
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
	GPIO_PinRemapConfig(GPIO_FullRemap_USART3, ENABLE);

	GPIO_InitStruct.GPIO_Pin = USART3_TX;
	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_Init(GPIOD, &GPIO_InitStruct);

	GPIO_InitStruct.GPIO_Pin = USART3_RX;
	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;
	GPIO_Init(GPIOD, &GPIO_InitStruct);

	NVIC_PriorityGroupConfig(NVIC_IPR0_PRI_2);
	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

	USART_InitStructure.USART_BaudRate = 115200;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
	USART_Init(USART3, &USART_InitStructure);
	USART_Cmd(USART3, ENABLE);
	USART_ITConfig(USART3,USART_IT_RXNE,ENABLE);
}

void Timer_Init()
{
	NVIC_InitTypeDef NVIC_InitStructure;
	TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);

	NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

	TIM_TimeBaseStructure.TIM_Period = TIMER_VALUE;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseStructure.TIM_Prescaler = 7199;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;

	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
	TIM_ClearFlag(TIM3, TIM_FLAG_Update);
	TIM_ITConfig(TIM3, TIM_IT_Update, ENABLE);
	TIM_Cmd(TIM3, ENABLE);
}

void Read_Airspeed_Data(uint8_t *RxBuffer,uint8_t Size)
{
	uint8_t Index = 0;
//	while (I2C_GetFlagStatus(SMBUS_PORT, I2C_FLAG_BUSY));

	I2C_GenerateSTART(SMBUS_PORT, ENABLE);

	while (!I2C_CheckEvent(SMBUS_PORT, I2C_EVENT_MASTER_MODE_SELECT));

	I2C_Send7bitAddress(SMBUS_PORT, (uint8_t)AIRSPEED_ADDRESS, I2C_Direction_Receiver);

	while (!I2C_CheckEvent(SMBUS_PORT, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));

	I2C_AcknowledgeConfig(SMBUS_PORT, ENABLE);

	for (Index = 0; Index < Size; Index++)
	{
		if (Index == (Size - 1))
		{
			I2C_AcknowledgeConfig(SMBUS_PORT, DISABLE);
			I2C_GenerateSTOP(SMBUS_PORT, ENABLE);

		}
		RxBuffer[Index] = I2C_ReceiveData(SMBUS_PORT);
		while (!I2C_CheckEvent(SMBUS_PORT, I2C_EVENT_MASTER_BYTE_RECEIVED));
	}

	I2C_AcknowledgeConfig(SMBUS_PORT, ENABLE);
}

void Read_Lidar_Data(uint8_t *TxBuffer, uint8_t *RxBuffer, uint8_t Size)
{
	uint8_t Index = 0;
//	while (I2C_GetFlagStatus(SMBUS_PORT, I2C_FLAG_BUSY));

	I2C_GenerateSTART(SMBUS_PORT, ENABLE);
	while (!I2C_CheckEvent(SMBUS_PORT, I2C_EVENT_MASTER_MODE_SELECT));
	I2C_Send7bitAddress(SMBUS_PORT, (uint8_t)ADDR_LIDAR, I2C_Direction_Transmitter);
	while (!I2C_CheckEvent(SMBUS_PORT, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));
	I2C_AcknowledgeConfig(SMBUS_PORT, ENABLE);


	Size = 4;
	for (Index = 0; Index < Size; Index++)
	{
		if (Index == (Size - 1))
		{
			I2C_AcknowledgeConfig(SMBUS_PORT, DISABLE);
			I2C_GenerateSTOP(SMBUS_PORT, ENABLE);

		}
		I2C_SendData(SMBUS_PORT, TxBuffer[Index]);
		while (!I2C_CheckEvent(SMBUS_PORT, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
	}

	I2C_GenerateSTOP(SMBUS_PORT, ENABLE);

	Size=7;

	I2C_GenerateSTART(SMBUS_PORT, ENABLE);
	while (!I2C_CheckEvent(SMBUS_PORT, I2C_EVENT_MASTER_MODE_SELECT));
	I2C_Send7bitAddress(SMBUS_PORT, (uint8_t)ADDR_LIDAR, I2C_Direction_Receiver);
	while (!I2C_CheckEvent(SMBUS_PORT, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));
	I2C_AcknowledgeConfig(SMBUS_PORT, ENABLE);


	for (Index = 0; Index < Size; Index++)
	{
		if (Index == (Size - 1))
		{
			I2C_AcknowledgeConfig(SMBUS_PORT, DISABLE);
			I2C_GenerateSTOP(SMBUS_PORT, ENABLE);

		}
		RxBuffer[Index] = I2C_ReceiveData(SMBUS_PORT);
		while (!I2C_CheckEvent(SMBUS_PORT, I2C_EVENT_MASTER_BYTE_RECEIVED));
	}

	I2C_AcknowledgeConfig(SMBUS_PORT, ENABLE);
}



